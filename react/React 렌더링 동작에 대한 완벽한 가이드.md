# React 렌더링 동작에 대한 완벽한 가이드

## 목차

- [렌더링이 뭘까요?](#렌더링이-뭘까요?)
  - 렌더링 프로세스 개요
  - 렌더 및 커밋 단계
- [리액트는 어떤 방식으로 렌더링할까요?](리액트는-어떤-방식으로-렌더링할까요?])
  - 렌더링 큐에 렌더링 등록하기
  - 일반적인 렌더링 동작
  - 리액트 렌더링 규칙
  - 컴포넌트 메터데이터와 파이버(Fibers)
  - 컴포넌트 타입(Component Types)과 재조정(Reconciliation)
  - Key와 재조정
  - 렌더링 일괄 처리(Render Batching)와 타이밍
  - 비동기 렌더링, 클로저 그리고 상태 스냅샷
  - 렌더링 동작 엣지 케이스



### 렌더링이 뭘까요?

렌더링이란 현재 props 및 상태를 기반으로 리액트가 컴포넌트에게 UI 영역이 어떻게 보이길 원하는지 설명을 요청하는 프로세스입니다.

#### 렌더링 프로세스 개요

렌더링 프로세스 동안 리액트는 컴포넌트 트리의 루트에서 시작해 업데이트가 필요하다고 표시된 모든 컴포넌트를 찾기 위해 아래로 순회합니다. 플래그가 지정된 각 컴포넌트에 대해 리액트는 함수 컴포넌트의 경우 ``FunctionComponent(props)``를, 클래스 컴포넌트의 경우 ``classComponentInstance.render()`` 를 호출하고 렌더 패스의 다음 단계를 위해 렌더 출력을 저장합니다.

컴포넌트 렌더 출력은 일반적으로 jsx 구문으로 작성되며 자바스크립트가 컴파일되고 배포를 위해 준비될 때 ``React.createElement()``호출로 변환됩니다. ``createElement``는 의도된 UI의 구조를 설명하는 일반 자바스크립트 객체인 React 요소를 반환합니다. 다음은 이에 대한 예시입니다.

```react
// JSX 구문입니다.
return <MyCompnent a={42} b="testing">Text here</MyCompnent>

// 아래와 같은 호출로 변환됩니다.
return React.createElement(MyComponent, {a: 42, b: "testing"}, "Text Here")

// 그리고 이것은 다음과 같은 요소 객체가 됩니다.
{type: MyComponent, props: {a: 42, b: "testing"}, children: ["Text Here"]}

// 그리고 내부적으로는 리액트가 실제 함수를 호출해 렌더링 합니다.
let elements = MyComponet({...props, children})

// HTML처럼 보이는 "호스트 컴포넌트"의 경우
return <button onClick={() => {}}>Click Me</button>
// 아래와 같이 호출되어
React.createElement("button", {onClick}, "Click Me")
// 최종적으로 아래와 같이 됩니다.
{type: "button", props: {onClick}, children: {"Click Me"}}
```

컴포넌트 트리 전체에서 렌더 출력을 수집한 후 리액트는 새로운 객체 트리(흔히 "가상 DOM"이라고 함)와 비교해 실제 DOM을 현재 원하는 출력과 같이 보이게 하기 위해 적용해야 할 모든 변경 사항 목록을 수집합니다. 비교 및 계산 프로세스는 "재조정(reconciliation)"으로 알려져 있습니다.

그런 다음 리액트는 계산된 모든 변경 사항을 하나의 동기 시퀀스로 DOM에 적용합니다.

>참고 : 리액트팀은 최근 몇 년간 "가상 DOM"이라는 용어를 멀리했습니다. DAn Abramov는 다음과 같이 말했습니다.
>
>저는 우리가 "가상 DOM"이라는 용어를 폐기할 수 있길 바랍니다. 2013년에는 지금과 달리 이렇게 이야기 하지 않으면 사람들은 리액트가 모든 렌더에서 DOM 노드르 생성한다고 생각했기 때문에 의미가 있었습니다. 그러나 오늘날 사람들은 이런 가정을 거의 하지 않습니다. "가상 DOM"은 일부 DOM 문제에 대한 해결 방법처럼 들리지만 리액트는 그런것이 아닙니다.
>
>리액트는 "값 UI"입니다. 그것의 핵심 원칙은 UI가 문자열이나 배열과 마찬가지로 값이라는 것입니다. 변수에 저장하고, 전달하고, 자바스크립트 제어 흐름에서 사용할 수 있습니다. 그 표현가능함이 요점입니다. DOM에 변경 사항을 적용하는 것을 피하기 위한 비교 같은 것이 아닙니다.
>
>항상 DOM을 나타내는 것도 아닙니다. 예를 들어 ``<Message recipientId={10} />``는 DOM이 아닙니다. 개념적으로 이는 지연 함수 호출 ``Message.bind(null, { recipientId: 10})``를 나타냅니다.

#### 렌더 및 커밋 단계

리액트 팀은 이 작업을 개념적으로 다음과 같은 두 단계로 나눕니다.

- "렌더 단계"에서는 컴포넌트 렌더링하고 변경 사항을 계산합니다.
- "커밋 단계"에서는 렌더 단계에서 계산된 변경 사항을 DOM에 적용합니다.

리액트는 커밋 단계에서 DOM을 업데이트한 후 요청된 DOM 요소 및 컴포넌트 인스턴스를 가리키도록 모든 참조를 적절하게 업데이트 합니다. 그 다음 ``componentDidMount`` 및 ``componentDidUpdate`` 클래스 라이프 사이클 메서드와 ``useLayoutEffect`` 훅을 동기적으로 실행합니다.

그런 다음 리액트는 짧은 시간 제한을 설정하고 이 시간이 만료되면 ``useEffect`` 훅을 실행합니다. 이 단계는 "패시브 이펙트(Passive Effects)" 단계라고도 합니다.

리액트 18은 ``useTransition``과 같은 "동시 렌더링" 기능을 추가했습니다. 이를 통해 리액트는 브라우저가 이벤트를 처리할 수 있도록 렌더링 단계에서 작업을 일시 중지할 수 있습니다. 리액트는 나중에 적절하게 작업을 재개하거나 폐기하거나 다시 계산합니다. 렌더 패스가 완료되면 리액트는 마찬가지로 커밋 단계를 동기적으로 실행합니다.

여기서 이해해야 할 핵심은 "렌더링"은 "DOM 업데이트"와 같지 않으며 결과적으로 어떠한 가시적인 변경도 일어나지 않고 컴포넌트가 렌더링될 수 있다는 것입니다.

- 컴포넌트가 지난번과 동일한 렌더 출력을 반환해 변경이 필요하지 않을 수 있습니다.
- 동시 렌더링에서 리액트는 컴포넌트를 여러 번 렌더링할 수 있지만 다른 업데이트로 인해 현재 수행 중인 작업이 무효화되는 경우 렌더 출력을 버립니다.

### 리액트는 어떤 방식으로 렌더링할까요?

#### 렌더링 큐에 렌더링 등록하기

첫 렌더링이 완료된 후 리액트에게 리렌더링을 큐에 등록하도록 지시하는 몇 가지 다른 방법이 있습니다.

- 함수 컴포넌트
  - ``useState`` setter
  - ``useReducer`` dispatch
- 클래스 컴포넌트
  - ``this.setState()``
  - ``this.forceUpdate()``
- 기타
  - ReactDOM의 최상위인 ``render(<APP>)`` 메서드를 다시 호출(루트 컴포넌트에서 ``forceUpdate``를 호출하는 것과 동일)
  - 새로 추가된 ``useSyncExternalStore`` 훅에서 트리거된 업데이트

함수 컴포넌트에는 ``forceUpdate`` 메서드가 없지만 항상 카운터를 증가시키는 ``useReducer`` 훅을 사용해 동일하게 동작할 수 있습니다.

```react
const [, forceRender] = useReducer((c) => c + 1, 0)
```

#### 일바적인 렌더링 동작

우리가 기억해야 할 아주 중요한 사항이 있습니다.

리액트의 기본 동작은 상위 컴포넌트가 렌더링될 때 리액트가 해당 컴포넌트 내부의 모든 하위 컴포넌트를 순환하며 렌더링한다는 것입니다!

예를 들어 ``A > B > C > D``인 컴포넌트 트리가 있고 이미 페이지에 표시되어 있다고 가정해 보겠습니다. 사용자는 ``B``에서 카운터를 증가시키는 버튼을 클릭합니다.

- `B`에서 `setState()`를 호출해 B의 리렌더링을 렌더링 큐에 넣습니다.
- 리액트는 트리 최상단에서 렌더 패스를 시작합니다.
- 리액트는 `A`가 업데이트가 필요하다고 표시되어 있지 않음을 확인하고 이를 지나갑니다.
- 리액트가 `B`가 업데이트가 필요하다고 표시되어 있음을 확인하고 렌더링합니다. `B`는 지난번과 같이 `<C />`를 반환합니다.
- `C`는 업데이트가 필요하다고 표시되지 않았지만 부모 `B`가 렌더링 되었기 때문에 리액트는 하위 컴포넌트인 `D`도 렌더링합니다.

즉, 컴포넌트를 렌더링하면 기본적으로 모든 하위 컴포넌트가 렌더링 됩니다!

또한 일반적인 렌더링에서 리액트는 "props가 변경 되었는지" 여부를 신경쓰지 않습니다. 부모가 렌더링되면 무조건 하위 컴포넌트를 렌더링합니다!

이는 루트 `<App>`컴포넌트에서 `setState()`를 호출하며 동작을 변경하는 다른 변경 사항 없이 리액트가 컴포넌트 트리의 모든 컴포넌트들을 리렌더링 하게됨을 의미합니다. 애초에 리액트의 세일즈 포인트 중 하나는 **"업데이트할 때마다 전체 앱을 다시 그리는 것처럼 동작합니다"**였습니다.

트리에서 대부분의 컴포넌트가 직전과 정확히 동일한 렌더 출력을 반환할 가능성이 매우 높으므로 리액트는 DOM을 변경할 필요가 없습니다. 그러나 리액트는 여전히 컴포넌트에 자체 렌더링을 요청하고 렌더 출력을 비교하는 작업을 수행해야 합니다. 둘 다 시간과 노력이 필요합니다.

기억해 둘 것은 렌더링은 나쁜 것이 아니라는 겁니다. 이는 리액트가 실제로 DOM을 변경해야 하는지 여부를 아는 방법일 뿐입니다!

#### 리액트 렌더링 규칙

리액트 렌더링의 기본 규칙 중 하나는 렌더링이 "순수"해야 하며 어떠한 사이드 이펙트도 없어야 한다는 것입니다!

이는 어렵고 혼란스러울 수 있는데, 왜냐하면 많은 사이드 이펙트가 명확하지 않고, 결과적으로 어떤것도 망가뜨리지 않기 때문입니다. 예를 들어 `console.log()`는 엄밀히 말해 사이드 이펙트지만 실제로는 아무것도 망가뜨리지 않습니다. prop을 변경하는 것은 명백히 사이드 이펙트고, 이는 아무것도 망가뜨리지 않을 수 있습니다. 렌더링 도중 AJAX 호출을 하는 것도 분명 사이드 이펙트이며, 요청 유형에 따라 예기치 못한 앱 동작이 발생할 수 있습니다.

Sebastian Markbage는 `The Rules of React`라는 제목의 훌륭한 글을 썼습니다. 글에서는 `render`를 포함한 리액트의 다양한 라이프 사이클 메서드에 대한 요구 동작과 어떤 동작이 안전하게 "순수"한지, 안전하지 않은지 정의합니다. 이 글은 전체적으로 읽을 가치가 있지만, 여기서는 핵심만 요약하겠습니다.

렌더 로직은 다음을 수행해선 안됩니다.

- 기존 변수 및 객체를 변경할 수 없습니다.
- `Math.random()`또는 `Date.now()`와 같은 임의의 값을 생성할 수 없습니다.
- 네트워크 요청을 할 수 없습니다.
- 상태 업데이트를 큐에 추가할 수 없습니다.

렌더 로직은 다음을 수행할 수 있습니다.

- 렌더링 도중 새로 생성된 객체 변경
- 오류 발생
- 캐시된 값과 같이 아직 생성되지 않은 데이터에 대한 "지연 초기화"

#### 컴포넌트 메타데이터와 파이버(Fibers)

리액트는 애플리케이션에 현재 존재하는 모든 컴포넌트 인스턴스를 추적하는 내부 데이터 구조를 저장합니다. 이 데이터 구조의 핵심 부분은 "파이버(Fiber)"라고 불리는 객체로 다음과 같은 메타 데이터 필드를 포함합니다.

- 컴포넌트 트리의 해당 지점에서 렌더링되어야 할 컴포넌트 타입
- 해당 컴포넌트와 관련된 prop, 상태
- 상위, 형제 및 하위 컴포넌트에 대한 포인터
- 리액트가 렌더링 프로세스를 추적하는 데 사용하는 기타 내부 메타데이터

리액트 버전이나 기능을 설명하는데 "리액트 파이버"라는 문구가 사용된 것을 들어본 적이 있다면, 이는 주요 데이터 구조가 "파이버" 객체에 의존하도록 리액트 내부 렌더링 로직을 변경하도록 재작성했다는 것을 의미했을 것입니다. 리액트 파이버는 리액트 16에서 출시되어 이후 모든 버전에서 이를 사용하고 있습니다.

`Fiber` 타입을 간단히 나타내면 다음과 같습니다.

```react
export type Fiber = {
    // 파이버 타입을 식별하기 위한 태그입니다.
    tag: WorkTag;
    
    // 해당 요소의 고유 식별자입니다.
    key: null | string;
    
    // 파이버와 관련된 것으로 확인된 함수/클래스 입니다.
    type: any;
    
    // 단일 연결 리스트 트리 구조입니다.
    child: Fiber | null;
    sibling: Fiber | null;
    index: number;
    
    // 파이버로 입력되는 데이터입니다. (arguments/props)
    pendingProps: any;
    memorizedProps: any; // 출력을 만드는데 사용되는 props입니다.
    
    // 상태 업데이트 및 콜백 큐 입니다.
    updateQueue: Array<state | stateUpdaters>;
    
    // 출력을 만드는데 사용되는 상태입니다.
 	memoizedState: any;

  	// 파이버에 대한 종속성(컨텍스트, 이벤트)입니다.(존재하는 경우)
  	dependencies: Dependencies | null;
};
```

렌더링 패스 동안 리액트는 이 파이버 객체 트리를 순회하고 새 렌더링 결과를 계산할 때 업데이트된 트리를 구성합니다.

명심할 점은 이 "파이버" 객체는 실제 컴포넌트 props와 상태 값을 저장한다는 것입니다. 컴포넌트에서 `props`와 `state`를 사용할 때 리액트는 사실 파이버 객체에 저장된 값에 대한 접근을 제공하는 것입니다. 실제로 클래스 컴포넌트의 경우 리액트는 렌더링 직전 `componentInstane.props = newProps`를 통해 명시적으로 이를 컴포넌트에 복사합니다. 따라서 `this.props`는 존재하지만 리액트가 내부 데이터 구조에서 참조를 복사했기 때문에 존재합니다. 그런의미에서 컴포넌트는 리액트 파이버 객체에 대한 일종의 외관입니다.

마찬가지로 리액트가 컴포넌트의 모든 훅을 해당 컴포넌트의 파이버 객체에 연결 리스트로 저장하기 때문에 리액트 훅이 동작합니다. 리액트가 함수 컴포넌트를 렌더링할 때 파이버에서 hook description entry를 담은 연결 리스트를 가져오고, 훅을 또 호출할 때마다 hook description 객체에 저장된 적절한 값(예를 들어 `useReducer`의 `state` 및 `dispatch` 값 등)을 반환합니다.

상위 컴포넌트가 주어진 하위 컴포넌트를 처음으로 렌더링할 때 리액트는 컴포넌트의 "인스턴스"를 추적하기 위해 파이버 객체를 만듭니다. 클래스 컴포넌트의 경우 문자 그대로 `const instance = new YourComponentType(props)`를 호출해 실제 컴포넌트 인스턴스를 파이버 객체에 저장합니다.함수 컴포넌트의 경우 리액트는 `YourComponentType(props)`를 함수로 호출합니다.

#### 컴포넌트 타입(Component Types)과 재조정(Reconciliation)

"재조정" 문서 페이지에 설명된 대로 리액트는 기존 컴포넌트 트리와 DOM 구조를 가능한 한 많이 재활용하여 효율적으로 리렌더링 하려고 노력합니다. 트리의 동일한 위치에 동일한 타입의 컴포넌트 또는 HTML 노드를 렌더링하도록 리액트에 요청하면 리액트는 처음부터 다시 만드는 대신 필요에 따라 업데이트를 적용합니다. 즉, 같은 위치에 해당 컴포넌트 타입을 렌더링 하도록 리액트에 계속 요청하는 동안 리액트는 컴포넌트 인스턴스를 활성 상태로 유지합니다. 클래스 컴포넌트의 경우 실제로 컴포넌트의 동일한 실제 인스턴스를 사용합니다. 함수 컴포넌트에는 클래스와 같은 진짜 "인스턴스"가 없지만 `<MyFunctionComponent />`가 "인스턴스"를 나타내는 것이라고 생각할 수 있습니다.

그렇다면 리액트는 출력이 실제로 변경된 시기와 방법을 어떻게 알 수 있을까요?

리액트 렌더링 로직은 먼저 `===` 참조 비교를 사용해 요소의 `type`필드를 기준으로 비교합니다. 지정된 지점의 요소가 `<div>`에서 `<span>` 또는 `<ComponentA>`에서 `<ComponentB>`로 변경되는 것과 같이 다른 타입으로 변경된 경우 리액트는 전체 트리가 변경되었다고 가정해 비교 프로세스의 속도를 높입니다. 결과적으로 리액트는 모든 DOM 노드를 포함해 기존 컴포넌트 트리 부분 전체를 삭제하고 새 컴포넌트 요소 인스턴스로 처음부터 다시 만듭니다.

즉, 렌더링하는 동안 새 컴포넌트 타입을 생성해서는 안됩니다. 새 컴포넌트 타입을 생성할 때마다 이 타입은 다른 참조가 되며, 이로 인해 리액트가 하위 컴포넌트 트리를 반복적으로 삭제 및 재생성 합니다.

다음과 같이 하지마세요.

```react
// ❌ BAD!
// 이는 매번 새로운 "ChildComponent" 참조를 생성합니다.
function ParentComponent() {
  function ChildComponent() {
    return <div>Hi</div>;
  }
  return <ChildComponent />;
}

// ✅ GOOD
// 이는 하나의 컴포넌트 타입 참조만 생성합니다.
function ChildComponent() {
  return <div>Hi</div>;
}

function ParentComponent() {
  return <ChildComponent />;
}
```

#### key와 재조정

리액트가 컴포넌트 인스턴스를 식별하는 또 다른 방법은 `key` psudo-prop을 사용하는 것입니다.  리액트는 `key`를 컴포넌트 타입의 특정 인스턴스를 구별하는데 사용할 수 있는 고유 식별자로 사용합니다.

`key`는 실제 prop이 아니라 리액트에 대한 지침임을 명심해야합니다. 리액트는 항상 이를 제거해 실제 컴포넌트에 전달되지 않으므로 `props.key`를 가질 수 없습니다. 이는 항상 `undefined`가 됩니다.

key는 주로 리스트를 렌더링할 때 사용됩니다. key는 리스트 아이템의 순서 변경, 추가 또는 삭제와 같은 방법으로 변경될 수 있는 데이터를 렌더링하는 경우 특히 중요합니다. 여기서 특히 중요한 것은 key가 가능한 한 데이터의 고유한 ID가 되어야 한다는 것입니다. 배열 인덱스만 key로 사용하는 것은 최후의 수단으로만 사용하세요!

```react
// ✅ 데이터 객체의 ID를 리스트 아이템의 key로 사용
todos.map((todo) => <TodoListItem key={todo.id} todo={todo} />);
```

이것이 왜 중요한지에 대한 예입니다. 배열 인덱스를 key로 사용해 10개의 `<TodoListItem>`컴포넌트 리스트를 렌더링한다고 가정해 보겠습니다. 리액트는 key가 `0..9`인 10개의 아이템을 마주합니다. 이제 아이템 6과 7을 삭제하고 끝에 세 개의 새 아이템을 추가하면 `0..10`의 key가 있는 아이템을 렌더링하게 됩니다. 따라서 리액트에게는 10개의 리스트 아이템에서 11개의 리스트 아이템으로 변경되었기 때문에 실제로 하나의 새 아이템을 추가한 것처럼 보입니다. 리액트는 기존 DOM 노드와 컴포넌트 인스턴스를 기꺼이 재사용 할 것입니다. 그러나 이는 리스트 아이템 #8에 전달된 할 일 아이템으로 `<TodoListItem key={6}>`를 렌더링하고 있음을 의미합니다. 즉, 컴포넌트 인스턴스는 여전히 유지되지만 이제 이전과 다른 데이터 객체를 prop으로 가져옵니다. 이 경우 제대로 동작할 수도 있지만 예기치 않은 동작을 초래할 수도 있습니다. 또한 기존 리스트 아이템이 이전과 다른 데이터를 표시해야 하기 때문에 리액트는 텍스트 및 기타 DOM 컨텐츠를 변경하기 위해 여러 리스트 아이템에 업데이트를 적용해야 합니다. 리스트 아이템이 변경되지 않았으므로 이러한 업데이트는 불필요합니다.

대신 각 리스트 아이템에 대해 `key={todo.id}`를 사용하는 경우 리액트는 두 아이템을 삭제하고 세 아이템을 추가한 것으로 올바르게 인식합니다. 그럼 삭제된 두 컴포넌트 인스턴스와 관련된 DOM이 삭제되고 세개의 새 컴포넌트 인스턴스와 이에 해당하는 DOM이 생성됩니다. 이는 실제로 변경되지 않은 컴포넌트를 불필요하게 업데이트한 것보다 낫습니다.

key는 리스트 외에도 컴포넌트 인스턴스 ID로도 유용합니다. 언제든지 리액트 컴포넌트에 `key`를 추가해 ID를 나타낼 수 있으며, 해당 key를 변경하면 리액트가 이전 컴포넌트 인스턴스와 DOM을 파괴하고 새 컴포넌트를 생성하게 됩니다. 일반적인 사용 사례는 리스트와 현재 선택한 리스트 아이템의 데이터를 표시하는 세부 정보 폼이 조합되는 경우입니다. `<DetailForm key={selectedItem.id}>`를 렌더링하면 선택한 항목이 변경될 때 리액트가 폼을 파괴하고 다시 생성하므로 폼 내에서 오래된 상태로 인한 문제가 발생하지 않습니다.

#### 렌더링 일괄 처리(Render Batching)와 타이밍

기본적으로 각 `setState()` 호출은 리액트가 새 렌더 패스를 시작하고 이를 동기적으로 실행하고 반환하도록 합니다. 그러나 리액트는 렌더링을 일괄 처리하는 형태로 일종의 최적화를 자동으로 적용하기도 합니다. 렌더링 일괄 처리는 여러 `setState()` 호출 결과가 단일 렌더 패스의 렌더링 큐에 전달되어 실행되는 경우를 말하며 일반적으로 약간의 지연이 발생합니다.

리액트 커뮤니티는 이를 "상태 업데이트가 비동기적일 수 있다"라고 설명합니다. 또한 새로운 리액트 문서에서는 이를 "상태는 스냅샷"이라고 설명합니다. 이것이 렌더링 일괄 처리 동작에 대한 레퍼런스입니다.

리액트 17 및 이전 버전에서 리액트는 `onClick` 콜백과 같은 리액트 이벤트 핸들러에서만 일괄처리를 수행했습니다. `setTimeout`, `await` 이후 또는 일반 JS 이벤트 핸들러와 같은 리액트 이벤트 핸들러 외에서의 업데이트는 큐에 추가되지 않았으며 각각 별도의 리렌더링이 발생했습니다.

그러나 리액트 18에서는 이제 단일 이벤트 루프 틱에 대기중인 모든 업데이트의 "자동 일괄 처리"를 수행합니다. 따라서 필요한 전체 렌더링 수를 줄일 수 있습니다.

구체적인 예를 살펴 보겠습니다.

```react
const [counter, setCounter] = useState(0);

const onClick = async () => {
  setCounter(0);
  setCounter(1);

  const data = await fetchSomeData();

  setCounter(2);
  setCounter(3);
};
```

리액트 17을 사용하면 3번의 렌더 패스를 실행하게 됩니다. 첫 번째 패스는 `setCounter(0)`과 `setCounter(1)`을 함께 일괄 처리하는데, 둘 다 원래의 이벤트 핸들러 호출 스택 중에 발생하기 때문이며, 따라서 둘 다 `unstable_batchedUpdates()`호출에서 업데이트가 발생하게 됩니다.

그러나 `setCounter(2)` 호출의 경우 `await` 이후 일어나게 됩니다. 즉, 원래의 동기적 호출 스택이 완료되었고, 함수의 후반부가 완전히 분리된 이벤트 루프 호출 스택에서 더 나중에 실행된다는 것입니다. 따라서 리액트는 `setCounter(2)` 호출 내부의 마지막 단계로 전체 렌더 패스를 동기적으로 실행하고 `setCounter(2)`의 실행을 종료합니다.

기존의 이벤트 핸들러 호출 스택 외에서 실행되고 따라서 배치 처리 대상에 포함되지 않기 때문에 `setCounter(3)`에 대해서도 동일한 일이 발생합니다.

하지만 리액트 18을 사용하면 렌더 패스가 두 번 실행됩니다. 처음 두 `setCounter(0)`와 `setCounter(1)`는 하나의 이벤트 루프 틱에 있으므로 함께 일괄 처리됩니다. 이후 `await` 다음의 `setCounter(2)`와 `setCounter(3)`가 모두 일괄 처리됩니다. 더 늦더라도 동일한 이벤트 루프에서 큐에 추가된 두 상태 업데이트이므로 두 번째 렌더링으로 일괄 처리됩니다.

