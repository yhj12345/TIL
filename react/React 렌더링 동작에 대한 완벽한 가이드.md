# React 렌더링 동작에 대한 완벽한 가이드

## 목차

- [렌더링이 뭘까요?](#렌더링이-뭘까요?)
  - 렌더링 프로세스 개요
  - 렌더 및 커밋 단계
- [리액트는 어떤 방식으로 렌더링할까요?](리액트는-어떤-방식으로-렌더링할까요?])
  - 렌더링 큐에 렌더링 등록하기
  - 일반적인 렌더링 동작
  - 리액트 렌더링 규칙
  - 컴포넌트 메터데이터와 파이버(Fibers)
  - 컴포넌트 타입(Component Types)과 재조정(Reconciliation)
  - Key와 재조정
  - 렌더링 일괄 처리(Render Batching)와 타이밍
  - 비동기 렌더링, 클로저 그리고 상태 스냅샷
  - 렌더링 동작 엣지 케이스



### 렌더링이 뭘까요?

렌더링이란 현재 props 및 상태를 기반으로 리액트가 컴포넌트에게 UI 영역이 어떻게 보이길 원하는지 설명을 요청하는 프로세스입니다.

#### 렌더링 프로세스 개요

렌더링 프로세스 동안 리액트는 컴포넌트 트리의 루트에서 시작해 업데이트가 필요하다고 표시된 모든 컴포넌트를 찾기 위해 아래로 순회합니다. 플래그가 지정된 각 컴포넌트에 대해 리액트는 함수 컴포넌트의 경우 ``FunctionComponent(props)``를, 클래스 컴포넌트의 경우 ``classComponentInstance.render()`` 를 호출하고 렌더 패스의 다음 단계를 위해 렌더 출력을 저장합니다.

컴포넌트 렌더 출력은 일반적으로 jsx 구문으로 작성되며 자바스크립트가 컴파일되고 배포를 위해 준비될 때 ``React.createElement()``호출로 변환됩니다. ``createElement``는 의도된 UI의 구조를 설명하는 일반 자바스크립트 객체인 React 요소를 반환합니다. 다음은 이에 대한 예시입니다.

```react
// JSX 구문입니다.
return <MyCompnent a={42} b="testing">Text here</MyCompnent>

// 아래와 같은 호출로 변환됩니다.
return React.createElement(MyComponent, {a: 42, b: "testing"}, "Text Here")

// 그리고 이것은 다음과 같은 요소 객체가 됩니다.
{type: MyComponent, props: {a: 42, b: "testing"}, children: ["Text Here"]}

// 그리고 내부적으로는 리액트가 실제 함수를 호출해 렌더링 합니다.
let elements = MyComponet({...props, children})

// HTML처럼 보이는 "호스트 컴포넌트"의 경우
return <button onClick={() => {}}>Click Me</button>
// 아래와 같이 호출되어
React.createElement("button", {onClick}, "Click Me")
// 최종적으로 아래와 같이 됩니다.
{type: "button", props: {onClick}, children: {"Click Me"}}
```

컴포넌트 트리 전체에서 렌더 출력을 수집한 후 리액트는 새로운 객체 트리(흔히 "가상 DOM"이라고 함)와 비교해 실제 DOM을 현재 원하는 출력과 같이 보이게 하기 위해 적용해야 할 모든 변경 사항 목록을 수집합니다. 비교 및 계산 프로세스는 "재조정(reconciliation)"으로 알려져 있습니다.

그런 다음 리액트는 계산된 모든 변경 사항을 하나의 동기 시퀀스로 DOM에 적용합니다.

>참고 : 리액트팀은 최근 몇 년간 "가상 DOM"이라는 용어를 멀리했습니다. DAn Abramov는 다음과 같이 말했습니다.
>
>저는 우리가 "가상 DOM"이라는 용어를 폐기할 수 있길 바랍니다. 2013년에는 지금과 달리 이렇게 이야기 하지 않으면 사람들은 리액트가 모든 렌더에서 DOM 노드르 생성한다고 생각했기 때문에 의미가 있었습니다. 그러나 오늘날 사람들은 이런 가정을 거의 하지 않습니다. "가상 DOM"은 일부 DOM 문제에 대한 해결 방법처럼 들리지만 리액트는 그런것이 아닙니다.
>
>리액트는 "값 UI"입니다. 그것의 핵심 원칙은 UI가 문자열이나 배열과 마찬가지로 값이라는 것입니다. 변수에 저장하고, 전달하고, 자바스크립트 제어 흐름에서 사용할 수 있습니다. 그 표현가능함이 요점입니다. DOM에 변경 사항을 적용하는 것을 피하기 위한 비교 같은 것이 아닙니다.
>
>항상 DOM을 나타내는 것도 아닙니다. 예를 들어 ``<Message recipientId={10} />``는 DOM이 아닙니다. 개념적으로 이는 지연 함수 호출 ``Message.bind(null, { recipientId: 10})``를 나타냅니다.

#### 렌더 및 커밋 단계

리액트 팀은 이 작업을 개념적으로 다음과 같은 두 단계로 나눕니다.

- "렌더 단계"에서는 컴포넌트 렌더링하고 변경 사항을 계산합니다.
- "커밋 단계"에서는 렌더 단계에서 계산된 변경 사항을 DOM에 적용합니다.

리액트는 커밋 단계에서 DOM을 업데이트한 후 요청된 DOM 요소 및 컴포넌트 인스턴스를 가리키도록 모든 참조를 적절하게 업데이트 합니다. 그 다음 ``componentDidMount`` 및 ``componentDidUpdate`` 클래스 라이프 사이클 메서드와 ``useLayoutEffect`` 훅을 동기적으로 실행합니다.

그런 다음 리액트는 짧은 시간 제한을 설정하고 이 시간이 만료되면 ``useEffect`` 훅을 실행합니다. 이 단계는 "패시브 이펙트(Passive Effects)" 단계라고도 합니다.

리액트 18은 ``useTransition``과 같은 "동시 렌더링" 기능을 추가했습니다. 이를 통해 리액트는 브라우저가 이벤트를 처리할 수 있도록 렌더링 단계에서 작업을 일시 중지할 수 있습니다. 리액트는 나중에 적절하게 작업을 재개하거나 폐기하거나 다시 계산합니다. 렌더 패스가 완료되면 리액트는 마찬가지로 커밋 단계를 동기적으로 실행합니다.

여기서 이해해야 할 핵심은 "렌더링"은 "DOM 업데이트"와 같지 않으며 결과적으로 어떠한 가시적인 변경도 일어나지 않고 컴포넌트가 렌더링될 수 있다는 것입니다.

- 컴포넌트가 지난번과 동일한 렌더 출력을 반환해 변경이 필요하지 않을 수 있습니다.
- 동시 렌더링에서 리액트는 컴포넌트를 여러 번 렌더링할 수 있지만 다른 업데이트로 인해 현재 수행 중인 작업이 무효화되는 경우 렌더 출력을 버립니다.

### 리액트는 어떤 방식으로 렌더링할까요?

#### 렌더링 큐에 렌더링 등록하기

첫 렌더링이 완료된 후 리액트에게 리렌더링을 큐에 등록하도록 지시하는 몇 가지 다른 방법이 있습니다.

- 함수 컴포넌트
  - ``useState`` setter
  - ``useReducer`` dispatch
- 클래스 컴포넌트
  - ``this.setState()``
  - ``this.forceUpdate()``
- 기타
  - ReactDOM의 최상위인 ``render(<APP>)`` 메서드를 다시 호출(루트 컴포넌트에서 ``forceUpdate``를 호출하는 것과 동일)
  - 새로 추가된 ``useSyncExternalStore`` 훅에서 트리거된 업데이트

함수 컴포넌트에는 ``forceUpdate`` 메서드가 없지만 항상 카운터를 증가시키는 ``useReducer`` 훅을 사용해 동일하게 동작할 수 있습니다.

```react
const [, forceRender] = useReducer((c) => c + 1, 0)
```

