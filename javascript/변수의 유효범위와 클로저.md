# 변수의 유효범위와 클로저

자바스크립트는 함수 지향 언어입니다. 이런 특징은 개발자에게 많은 자유를 줍니다. 함수를 동적으로 생성할 수 있고, 생성한 함수를 다른 함수에 인수로 넘길 수 있으며, 생성된 곳이 아닌 곳에서 함수를 호출할 수도 있기 때문입니다.

### 

### 코드 블록

코드 블록 `{...}` 안에서 선언한 변수는 블록 안에서만 사용할 수 있습니다.

```js
{
    let message = "안녕하세요";

    alert(message); // 안녕하세요
}

alert(message) // ReferenceError: message is not defined
```

`if`, `for`, `while` 등에서도 마찬기로 `{...}` 안에서 선언한 변수는 오직 블록 안에서만 접근 가능합니다.

### 중첩 함수

함수 내부에서 선언한 함수는 '중첩(nested)' 함수라고 부릅니다.

자바스크립트에선 손쉽게 중첩 함수를 만들 수 있습니다.

중첩 함수는 아래와 같이 코드를 정돈하는데 사용할 수 있습니다.

```js
function sayHiBye(firstName, lastName) {
    // 헬퍼(helper) 중첩 함수
    function getFullName() {
        return firstName + " " + lastName;
    }
    alert( "Hello, " + getFullName() );
    alert( "Bye, " + getFullName() );
}
```

위 예시에서 외부 변수에 접근해 이름 전체를 반환해주는 중첩함수 `getFullName()`은 편의상 만든 함수입니다. 이렇게 자바스크립트에선 중첩 함수가 흔히 사용됩니다.

중첩 함수는 새로운 객체의 프로퍼티 형태나 중첩 함수 그 자체로 반환될 수 있다는 점에서 흥미롭습니다. 이렇게 반환된 중첩 함수는 어디서든 호출해 사용할 수 있습니다. 물론 이때도 외부 변수에 접근할 수 있다는 사실은 변함없습니다.

아래 함수 `makeCounter`는 호출될 때마다 다음 숫자를 반환해주는 '카운터' 함수를 만듭니다.

```js
function makeCounter() {
    let count = 0;
    return function() {
        return count++;
    };
}

let counter = makeCounter();

alert( counter() ); // 0
alert( counter() ); // 1
alert( counter() ); // 2
```

그런데 makeCounter 를 살펴보다 보면 “ counter 를 여러 개 만들었을 때, 이 함수들은 서로 독립적일까? 

함수와 중첩 함수 내 count 변수엔 어떤 값이 할당될까?” 같은 의문이 들기 마련입니다.

### 렉시컬 환경

#### 단계 1. 변수

자바스크립트에선 실행 중인 함수, 코드 블록 `{...}`, 스크립트 전체는 렉시컬 환경이라 불리는 내부 숨김 연관 객체를 갖습니다.

렉시컬 환경 객체는 두 부분으로 구성됩니다.

1. 환경 레코드(Environment Record) - 모든 지역 변수를 프로퍼티로 저장하고 있는 객체입니다.

2. 외부 렉시컬 환경(Outer Lexical Environment)에 대한 참조 - 외부 코드와 연관됨

'변수'는 특수 내부 객체인 `환경 레코드`의 프로퍼티일 뿐입니다. '변수를 가져오거나 변경'하는 것은 '환경 레코드의 프로퍼티를 가져오거나 변경'함을 의미합니다.

아래 두 줄짜리 코드엔 렉시컬 환경이 하나만 존재합니다.

<img src="file:///C:/Users/ghwns/AppData/Roaming/marktext/images/2023-08-09-18-55-54-image.png" title="" alt="" data-align="center">

이렇게 스크립트 전체와 관련된 렉시컬 환경은 전역 렉시컬 환경이라고 합니다.

위 그림에서 네모 상자는 변수가 저장되는 환경 레코드를 나타내고 붉은 화살표는 외부 렉시컬 환경에 대한 참조를 나타냅니다. 전역 렉시컬 환경은 외부 참조를 갖지 않기 때문에 화살표가 `null`을 가리키는 걸 확인할 수 있습니다.

코드가 실행되고 실행 흐름이 이어져 나가면서 렉시컬 환경은 변화합니다.

<img src="file:///C:/Users/ghwns/AppData/Roaming/marktext/images/2023-08-09-18-58-24-image.png" title="" alt="" data-align="center"> 우측의 네모 상자들은 코드가 한 줄, 한줄 실행될 떄마다 전역 렉시컬 환경이 어떻게 변화하는지 보여줍니다.

#### 단계2 . 함수선언문

함수 선언문으로 선언한 함수는 일반 변수와는 달리 바로 초기화됩니다.

함수 선언문으로 선언한 함수는 렉시컬 환경이 만들어지는 즉시 사용할 수 있습니다. 

<img src="file:///C:/Users/ghwns/AppData/Roaming/marktext/images/2023-08-09-19-00-57-image.png" title="" alt="" data-align="center">

#### 단계3. 내부와 외부 렉시컬 환경

함수를 호출해 실행하면 새로운 렉시컬 환경이 자동으로 만들어집니다. 이 렉시컬 환경엔 함수 호출 시 넘겨받은 매겨변수와 함수의 지역 변수가 저장됩니다.

`say("John")`을 호출하면 아래와 같은 내부 변화가 일어납니다.

<img src="file:///C:/Users/ghwns/AppData/Roaming/marktext/images/2023-08-09-19-35-40-image.png" title="" alt="" data-align="center">

함수가 호출 중인 동안엔 호출 중인 함수를 위한 내부 렉시컬 환경과 내부 렉시컬 환경이 가리키는 외부 렉시컬 환경을 갖게 됩니다.

- 예시의 내부 렉시컬 환경은 현재 실행 중인 함수인 `say`에 상응합니다. 내부 렉시컬 환경엔 함수의 인자인 `name`으로부터 유래한 프로퍼티 하나만 있습니다. `say("John")`을 호출했기 때문에, `name`의 값은 `"John"` 이 됩니다.

- 예시의 외부 렉시컬 환경은 전역 렉시컬 환경입니다. 전역 렉시컬 환경은 `phrase`와 함수 `say`를 프로퍼티로 갖습니다.

그리고 내부 렉시컬 환경은 `외부` 렉시컬 환경에 대한 참조를 갖습니다.

코드에서 변수에 접근할 땐, 먼저 내부 렉시컬 환경을 검색 범위로 잡습니다. 내부 렉시컬 환경에서 원하느 변수를 찾지 못하면 검색 범위를 내부 렉시컬 환경이 참조하는 외부 렉시컬 환경으로 확장합니다. 이 과정은 검색 범위가 전역 렉시컬 환경으로 확장될 때까지 반복됩니다.

예시와 그림을 보면서 변수 검색이 어떻게 진행되는지 다시 정리해 봅시다.

- 함수 `say` 내부의 `alert`에서 변수 `name`에 접근할 땐, 먼저 내부 렉시컬 환경을 살펴봅니다. 내부 렉시컬 환경에서 변수 `name`을 찾았습니다.

- `alert`에서 변수 `phrase`에 접근하려는데, `phrase`에 상응하는 프로퍼티가 내부 렉시컬 환경엔 없습니다. 따라서 검색 범위는 외부 렉시컬 환경으로 확장됩니다. 외부 렉시컬 환경에서 `phrase`를 찾았습니다.

<img src="file:///C:/Users/ghwns/AppData/Roaming/marktext/images/2023-08-09-19-49-58-image.png" title="" alt="" data-align="center">

#### 단계4. 함수를 반환하는 함수

```js
function makeCounter() {
    let count = 0;
    return function() {
        return count++;
    };
}

let counter = makeCounter();
```

`makeCouter()`를 호출하면 호출할 때마다 새로운 렉시컬 환경 객체가 만들어지고 여기에 `makeCounter`를 실행하는데 필요한 변수들이 저장됩니다.

위쪽에서 살펴본 `say("John")` 예시와 마찬가지로 `makeCounter()`를 호출할 때도 두 개의 렉시컬 환경이 만들어집니다.

<img src="file:///C:/Users/ghwns/AppData/Roaming/marktext/images/2023-08-09-19-52-39-image.png" title="" alt="" data-align="center">

현재는 중첩함수가 생성되기만 하고 실행을 되지 않은 상태입니다.

모든 함수는 함수가 생성된 곳의 렉시컬 환경을 기억합니다. 함수는 `[[Environment]]`라 불리는 숨김 프로퍼티를 갖는데, 여기에 함수가 만들어진 곳의 렉시컬 환경에 대한 참조가 저장됩니다.

<img src="file:///C:/Users/ghwns/AppData/Roaming/marktext/images/2023-08-09-19-55-43-image.png" title="" alt="" data-align="center">

따라서 `counter.[[Environment]]`엔 `{ count: 0 }`이 있는 렉시컬 환경에 대한 참조가 저장됩니다. 호출 장소와 상관없이 함수가 자신이 태어난 곳을 기억할 수 있는 건 바로 이 `[[Environment]]` 프로퍼티 덕분입니다. `[[Environment]]`는 함수가 생성될 때 딱 한 번 값이 세팅되고 영원히 변하지 않습니다.

`counter()`를 호출하면 각 호출마다 새로운 렉시컬 환경이 생성됩니다. 그리고 이 렉시컬 환경은 `couter.[[Environment]]`에 저장된 렉시컬 환경을 외부 렉시컬 환경으로서 참조합니다.

<img src="file:///C:/Users/ghwns/AppData/Roaming/marktext/images/2023-08-09-20-00-07-image.png" title="" alt="" data-align="center">

실행 흐름이 중첩 함수의 본문으로 넘어오면 `count` 변수가 필요한데, 먼저 자체 렉시컬 환경에서 변수를 찾습니다. 익명 중첩 함수엔 지역변수가 없기 때문에 이 렉시컬 환경을 비어있는 상태입니다. 이제 `count()`의 렉시컬 환경이 참조하는 외부 렉시컬 환경에서 `count` 변수를 찾습니다.

이제 `count++`가 실행되면서 count 값이 1 증가해야하는데, 변숫값 갱신은 변수가 저장된 렉시컬 환경에서 이뤄집니다.

따라서 실행이 종료 된 후의 상태는 다음과 같습니다.

<img src="file:///C:/Users/ghwns/AppData/Roaming/marktext/images/2023-08-09-20-02-19-image.png" title="" alt="" data-align="center">

`counter()`를 여러 번 호출되면 `count` 변수가 `2`, `3`으로 증가하는 이유가 바로 여기에 있습니다.

### 클로저

'클로저(closure)'는 개발자라면 알고 있어야 할 프로그래밍 용어입니다.

클로저는 외부 변수를 기억하고 이 외부 변수에 접근할 수 있는 함수를 의미합니다. 몇몇 언어에선 클로저를 구현하는게 불가능하거나 특수한 방식으로 함수를 작성해야 클로저를 만들 수 있습니다. 하지만 자바스크립트에선 모든 함수가 자연스럽게 클로저가 됩니다.

자바스크립트의 함수는 숨김 프로퍼티인 `[[Environment]]`를 이용해 자신이 어디서 만들어졌는지 기억합니다. 함수 본문에선 `[[Environment]]`를 사용해 외부 변수에 접근합니다.
